## 为什么要禁用拷贝构造函数和复制函数？
1. 浅拷贝问题，对指证的拷贝，容易导致 double free 问题
2. 基类拷贝构造问题，自定义实现的拷贝够找函数需要手动调用积累的拷贝够找函数

禁用拷贝够找函数的方法：
1. 变为私有成员
2. 使用 delete 关键字

禁用拷贝构造函数时要确定自己不会再调用拷贝构造函数，禁用拷贝构造函数后：
1. 不能将实例对象插入容器
2. 不能进行赋值初始化，如：`A a = a1`
3. 不能作为实参传递和返回值
4. 任何包含了禁用拷贝对象的类，其默认的拷贝构造函数也会失效，因为在默认的拷贝构造函数中，会依次调用其包含对象的拷贝构造函数。（例如： std::mutex 中禁用了拷贝构造函数，所有包含 std::mutex 的类调用拷贝构造函数时，会出现 `use delete function std::mutex(const std::mutex &)` 错误)

## 移动语义
C++11 新增了移动语义，移动语义直接在临时对象上建立对象（如：函数返回值），相比于拷贝够找减少了一次对象的拷贝操作。但是移动够找函数会销毁原对象，因此在手动实现时需要注意将指针致公。