@startuml
start
    #hotpink:while(1);
    
    'while (<color:hotpink>while(1));
    if(（KeyFramesWaitCheck 为空？ || KeyFramesWaitCheck 中第一个元素的mnId大于局部地图的关键帧最小mnId） 
      && SLAM 系统运行未结束) then (yes)
      : sleep 4s]
      if ( KeyFramesWaitCheck 为空？ ) then (yes)
        : 提取 KeyFramesWaitCheck 中的待检查关键帧到 KeyFramesWaitCheck ,
          并清空 mlKeyFramesWaitCheck]
      else (继续存储数据)
      endif

      if(KeyFramesWaitCheck 非空 && KeyFramesWaitCheck 中第一个元素的mnId大于局部地图的关键帧最小mnId) then (yes)
        : 更新加锁变量 mLocalMinMPId、mLocalMinKFId、mMapMaxKFid]
        if (KeyFramesWaitCheck 中第一个元素的mnId大于局部地图的关键帧最小mnId) then (yes)
          #hotpink: goto while(1);
          detach  
        else (no)
        endif
      else (no)
      endif
    else (no)
    endif

    if (KeyFramesWaitCheck 非空？)then (yes)    
      : 获取 vpDeleteMPs 中最大的 mnId]
      if ( vpDeleteMPs 中待存储地图点的最大mnId < Tracking 中局部地图中地图点的最小mnId && 系统运行未结束) then (no)
          '#hotpink: goto while(1) ;
          'detach
      else (yes)
        : 统计已存储地图的大小，更新地图是否可以存储的标志 saveBlockMap]
        if ( 是否保存地图 saveBlockMap = true ? ) then (yes)
          partition AddKeyFramesToBlock {
          : 获取关键帧的块坐标]
          if (关键帧块是否被创建？) then (no)
          : 创建关键帧块]
            note left
            new 
            end note
          else (yes)
          endif
          : 将 vpDeleteKFs 中的添加到 mKeyFrameBlockTemp 对应的地图块中]
          }
            
          partition MergeKeyFrameBlock {
            if (关键帧没存储过？) then (yes)
              partition BlockLoad{
                : 根据 mBlockDatabase 中记录的关键帧块与地图点块的对应关系,
                  加载对应的地图点块 mMapPointBlockLoading]
                  note left
                  new 
                  end note
                : 加载存储的关键帧块 mKeyFrameBlockLoading]
                  note left
                  new 
                  end note
                : 恢复加载的关键帧对地图点的观测信息]
              }
              : mKeyFrameBlockLoading 中的关键帧加入 mKeyFrameBlockTemp]
            else (no)
            endif
            : mKeyFrameBlockTemp 加入 mKeyFrameBlockWaiting]

          }
          
          partition SaveKeyFrameBlock {
            : 设置关键帧块的表头信息，<color:red>同时记算关键帧块与地图点块的对应关系]
            : 将关键帧块的表头添加到 BlockDatabase]
            : 存储 mKeyFrameBlockWaiting 中的地图点块]
            : 删除 mKeyFrameBlockWaiting 中的地图点块]
            note right
            delete
            end note
          }
          
          : 删除 mMapPointBlockLoading 中的地图点块和<color:red>其中的地图点]
          note right
          delete
          end note
          : 删除 mKeyFrameBlockLoading 中的地图点块和<color:red>其中的地图点]
          note right
          delete
          end note
        else (no)
        endif
        
        : 将 vpDeleteKFs 中的关键帧追加到 vpTryDeleteKFs 中]
        partition DeleteKeyFrames {
          repeat: 获取 vpTryDeleteKFs 中的一个地图点
          if (关键帧观察到了未被存储的地图点) then (yes)
            : 暂不删除关键帧]
          else (no)
            partition SetBadFlag() {
              : 删除关键帧之间的连接关系,(mConnectedKeyFrameWeights)]
              : 清除地图点对当关键帧的观测]
              : 为当强关键帧的字节点重新选取父节点]
              : 在当前关键帧的父节点的 childrens 中删除关于当强关键帧的信息]
            }
            : 将关键帧标记为已删除,release 关键帧]
            note right
            release 
            end note
          endif
          repeat while(处理完 vpTryDeleteKFs 中的所有关键帧？) is (no) not (yes)
        }
        : 更新下一次保持的关键帧窗口的,mStratKeyFrameID += mWindowSize]
        : 清空 vpDeleteKFs]
      endif
    else (no)
    endif
    'end while
    '-[hidden]->

    if (SLAM系统结束 && Atlas处理完成) then (yes)
      if ( 是否保存地图 saveBlockMap = true ? ) then (yes)
        : 保存分块数据库 mBlockDatabase]
      else (no)
      endif
    #hotpink: 退出循环;
    else (no)
      #hotpink: goto while(1) 开始下一次循环;
      detach
    endif
  stop
@enduml