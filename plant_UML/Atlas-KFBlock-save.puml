@startuml
start
    'while (<color:hotpink>while(1));
    if ( KeyFramesWaitCheck 为空？ ) then (yes)
    : 提取 KeyFramesWaitCheck 中的待检查关键帧到 KeyFramesWaitCheck ，
      并清空 KeyFramesWaitCheck]
    else (继续存储数据)
    endif

    : 获取 mlKeyFramesWaitCheck 中的一个关键帧;
    partition CheckKeyFrameSave {
    if (SLAM 系统运行结束？) then (no)
      : 获取局部地图和当前关键帧的共视帧中的最小mnId]
      if (下一次保存窗口的阈值 < 最小mnId ?) then (yes)
      : 当前判断的关键帧加入待存储列表 vpDeleteKFs ]
      else (no)
      endif
    else (yes)
      if (下一次保存窗口的阈值 < 地图中关键帧的最大mnId) then (yes)
      : 将窗口内的关键帧加入待存储列表 vpDeleteKFs]
      else
      : 将地图中剩余的关键帧都加入待存储列表 vpDeleteKFs]
      endif
    endif
    }
    
    : 获取 vpDeleteMPs 中最大的 mnId]
    if ( vpDeleteMPs 中待存储地图点的最大mnId < Tracking 中局部地图中地图点的最小mnId && 系统运行未结束) then (no)
        '#hotpink: goto while(1) ;
        'detach
    else (yes)
      if (保存分块地图？) then (yes)
        partition AddKeyFramesToBlock {
        : 获取关键帧的块坐标]
        if (关键帧块是否被创建？) then (no)
        : 创建关键帧块]
          note left
          new 
          end note
        else (yes)
        endif
        : 将 vpDeleteKFs 中的添加到 mKeyFrameBlockTemp 对应的地图块中]
        }
          
        partition MergeMapPointBlock {
          if (关键帧没存储过？) then (yes)
            partition BlockLoad{
              : 根据 mBlockDatabase 中记录的关键帧块与地图点块的对应关系,
                加载对应的地图点块 mMapPointBlockLoading]
                note left
                new 
                end note
              : 加载存储的关键帧块 mKeyFrameBlockLoading]
                note left
                new 
                end note
              : 恢复加载的关键帧对地图点的观测信息]
            }
            : mKeyFrameBlockLoading 中的关键帧加入 mKeyFrameBlockTemp]
          else (no)
          endif
          : mKeyFrameBlockTemp 加入 mKeyFrameBlockWaiting]

        }
        
        partition SaveKeyFrameBlock {
          : 设置关键帧块的表头信息，<color:red>同时记算关键帧块与地图点块的对应关系]
          : 将关键帧块的表头添加到 BlockDatabase]
          : 存储 mKeyFrameBlockWaiting 中的地图点块]
          : 删除 mKeyFrameBlockWaiting 中的地图点块]
          note right
          delete
          end note
        }
        
        : 删除 mMapPointBlockLoading 中的地图点块和<color:red>其中的地图点]
        note right
        delete
        end note
        : 删除 mKeyFrameBlockLoading 中的地图点块和<color:red>其中的地图点]
        note right
        delete
        end note
      else (no)
      endif
      
      : 将 vpDeleteKFs 中的关键帧追加到 vpTryDeleteKFs 中]
      partition DeleteKeyFrames {
        repeat: 获取 vpTryDeleteKFs 中的一个地图点
        if (关键帧观察到了未被存储的地图点) then (yes)
          : 暂不删除关键帧]
        else (no)
          partition SetBadFlag() {
            : 删除关键帧之间的连接关系,(mConnectedKeyFrameWeights)]
            : 清除地图点对当关键帧的观测]
            : 为当强关键帧的字节点重新选取父节点]
            : 在当前关键帧的父节点的 childrens 中删除关于当强关键帧的信息]
          }
          : 将关键帧标记为已删除,release 关键帧]
          note right
          release 
          end note
        endif
        repeat while(处理完 vpTryDeleteKFs 中的所有关键帧？) is (no) not (yes)
      }
      : 更新下一次保持的关键帧窗口的,mStratKeyFrameID += mWindowSize]
      : 清空 vpDeleteKFs]
    endif
    'end while
    '-[hidden]->

    if (SLAM系统结束 && Atlas处理完成) then (yes)
      if (保存分块地图？) then (yes)
        : 保存分块数据库 mBlockDatabase]
      else (no)
      endif
    #hotpink: 退出循环]
    else (no)
      if(KeyFramesWaitCheck 为空？) then (yes)
        :sleep(1)]
      else (no)
      endif
      #hotpink: goto while(1) 开始下一次循环]
      detach
    endif
  stop
@enduml