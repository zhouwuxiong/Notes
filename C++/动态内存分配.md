## 
1. 每次调用free函数后，内存并没有立刻归还给系统，当下次申请相同的大小的内存时，会直接分配上次free的内存。
2. 当调用free函数后，如果释放的内存中产生了大于 128K 的连续区域，那么会将其连接为 >=128K 的大内存
3. 当free后，最高地址的内存大于 128K ，则会自动调用 malloc_trim() 进行内存紧缩，堆的基地址向高位扩展（移动_data指针）。
4. malloc_trim()

参考：
[内存泄漏之malloc_trim](https://www.cnblogs.com/zhanggaofeng/p/15941542.html)


## Note:
**系统会为对分配一个按内存大小排序的链表，当每次分配内存时，会遍历链表直到找到一个大小合适的内存，分配给程序，如果分配的内存大于程序申请的内存，则会将内存切分并将多余的内存挂载到内存分配的链表上**，这也是为什么当你 free 或 delete 一个变量后，立即 new 一个相同的对象时，往往会直接使用上一次释放的内存地址，因为这些大小合适的内存块会被挂载到链表的最前面，所以会被优先分配。

## 
- 当开辟的空间小于 128K 时，调用 brk（）函数，malloc 的底层实现是系统调用函数 brk（），其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)
- 当开辟的空间大于 128K 时，mmap（）系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。

(https://juejin.cn/post/7023679009925890085)


[C/C++内存分配](https://www.cnblogs.com/hanerfan/p/4545370.html)

