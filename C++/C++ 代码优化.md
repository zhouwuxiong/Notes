# 语法
1. 善用 & 和 && 避免创建临时对象，特别是对象的构造函数的操作复杂或存在大量的构造函数递归调用时。

2. 使用初始化列表代替赋值初始化（少调用一次赋值构造函数）

## 巧用内联函数 
3. 如果函数调用频繁并且功能简单，可以定义为内联函数避免上下文切换的开销
需要注意的是：
- 如果将冗长的函数递定义为内联函数，会导致可执行文件的大小和内存占用的增加
- 在**类內定义** 定义的函数默认为内联函数，称为**隐式内联函数**
- 内联函数只是对编译器的建议，具体是否生效取决于编译器的优化

# 容器的使用
## 序列容器
1. 避免内存扩容 
vector 在初始化时不会分配内存空间，在第一次插入元素后会分配1个元素大小的空间，在之后的元素插入会以2倍（GCC）或 1.5 倍进行扩容。可以在定义时指定vector的容量，也可以再插入多个元素时使用reserve一次分配足够大小的容量。
*所以vector的容量增长是：1，2，4，8 ??*
```C++
vector a(10)    //定义时指定容量
a.reserve(100)  // 插入前指定容量
```
*为什么Vector要以2倍的方式扩容？可能vector的内存分配在堆空间，堆空间的空闲内存链表是以2倍的增长的*
## 关联容器
1. 选择合理的排序方式，特别是元素为指针时。

2. 如果需要频繁查询、插入、删除时使用 Hash 容器 和 关联容器，但关联容器的遍历比hash更快，需要随机访问时使用顺序容器。

# 锁的使用
1. 避免锁竞争，减少锁的访问频率。例如：在变量加锁读写操作时，可以一次处理多个数据。尽量将带锁的函数写到循环外。

2. 降低锁的粒度，尽量避免多个资源共用一把锁

3. 降低锁等待的时间，例如：最小化加锁的区域，加锁区的操作尽可能简单，最好将资源缓存到本地处理，锁区域只做数据读写操作

4. 选择合适的加锁方式，例如：使用读写锁替代互斥锁

