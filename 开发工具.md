## valgraind
Valgrind是一套Linux下，开放源代码（GPL V2）的仿真调试工具的集合。Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。
```shell
# 1. 安装
sudo apt-get install massif-visualizer
# 2. 使用，生成massif文件
valgrind --tool=massif ./palmGateMachine
# 3. 查看
massif-visualizer
```
### valgraind 工具
-  valgraind 与CPU的实现细节相关
#### 1.Memcheck
最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，一切对malloc()/free()/new/delete的调用都会被捕获。所以，它能检测以下问题：
- 对未初始化内存的使用；
- 读/写释放后的内存块；
- 读/写超出malloc分配的内存块；
- 读/写不适当的栈中内存块；
- 内存泄漏，指向一块内存的指针永远丢失；
- 不正确的malloc/free或new/delete匹配；
- memcpy()相关函数中的dst和src指针重叠。

[Valgrind安装及使用](https://blog.csdn.net/tannanxi/article/details/119671984)
[Valgrind详细教程（1） Memcheck](https://blog.csdn.net/tissar/article/details/87194737)

#### 2.Callgrind
和**gprof**类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，**建立函数调用关系图**，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。

#### 3.Cachegrind
Cache分析器，它**模拟CPU中的一级缓存I1，Dl和二级缓存，能够精确地指出程序中cache的丢失和命中**。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。

#### 4.Helgrind
它主要用来**检查多线程程序中出现的竞争问题**。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为“Eraser”的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，Helgrind仍然处于实验阶段。
#### 5.Massif
堆栈分析器，它能**测量程序在堆栈中使用了多少内存**，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。
此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具。

[valgrind 的使用](https://www.jianshu.com/p/5a31d9aa1be2)
[内存泄漏检测工具valgrind神器](https://zhuanlan.zhihu.com/p/75416381)

## gprof 
改进应用程序的性能是一项非常耗时耗力的工作，但是究竟程序中是哪些函数消耗掉了大部分执行时间，这通常都不是非常明显的。GNU 编译器工具包所提供了一种剖析工具 GNU profiler（gprof）。gprof 可以为 Linux平台上的程序精确分析性能瓶颈。gprof精确地给出函数被调用的时间和次数，给出函数调用关系。

**gprof2dot** 是对 **gprof**的输出结果图形化的工具。

[gprof 用户手册网站](http://sourceware.org/binutils/docs-2.17/gprof/index.html)
[linux环境下 C++性能测试工具 gprof 和gprof2dot ](https://www.cnblogs.com/xuxm2007/archive/2012/02/28/2372057.html)

## gtest
单元测试工具

## Datafaker
是大型测试数据和流量测试数据生成工具。它是基于python开发，需要安装mysql

## 程序性能分析工具
| 名称       | 功能                                                                                     | 优点                                                                               | 缺点                                                                                      |
| ---------- | ---------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| gprof      | 获取每个函数的调用次数以及运行时间                                                       | 无需安装，GUN自带；使用方便                                                        | 不适用于多线程程序以及function pointers；可视化工具一般；软件本身好像不是用来做性能分析的 |
| valgrind   | 除了查看，还有很多其他工具（内存泄漏啥的）                                               | 功能全；可视化工具完善                                                             | 运行速度特别慢（比普通程序慢10倍很正常）；由于功能太多，学习成本较高                      |
| gperftools | 查找程序运行热点（不能知道单个函数单次运行时间，而是获得每个函数运行时间占整体的百分比） | 使用方便，对程序整体速度影响小                                                     | 功能单一（其他的都好像能做别的事情）；可视化工具一般                                      |
| perf       | 类似 gperftools，不过针对的是整体Linux内核；功能强大                                     | 内核工具，不仅可用来分析单个程序，还可用来分析整机性能；可视化工具很好看；功能完善 | 函数名有很多 Unknown，当前函数感觉函数名看不懂……                                          |
| VTune      | Intel CPU性能测试工具                                                                    | 大家都说好，没用过，我也不知道好在哪里                                             | 付费软件（这一条就打败了所有）                                                            |

### 性能分析工具
[C++ 性能分析工具调研](https://blog.csdn.net/irving512/article/details/117077847)
[Linux 性能分析工具汇总](https://cloud.tencent.com/developer/article/1827303)

[AddressSanitizerComparisonOfMemoryTools](https://github.com/google/sanitizers/wiki/AddressSanitizerComparisonOfMemoryTools)

## 程序性能优化 - 火焰图

![不同类型的火焰图](images/flame%20graph%20classify.jpg)
### 分析
- 纵轴代表调用栈的深度（栈桢数），用于表示函数间调用关系：下面的函数是上面函数的父函数。
- 横轴代表调用频次，一个格子的宽度越大，越说明其可能是瓶颈原因。
- 不同类型火焰图适合优化的场景不同，比如 on-cpu 火焰图适合分析 cpu 占用高的问题函数，off-cpu 火焰图适合解决阻塞和锁抢占问题。
- 无意义的事情：横向先后顺序是为了聚合，跟函数间依赖或调用关系无关；火焰图各种颜色是为方便区分，本身不具有特殊含义
### 使用 perf 绘制火焰图
1. 安装 perf
```Shell
# update 更新版本库
# upgrade 更新程序
sudo apt-get update; apt-get upgrade
```
2. 生成火焰图
```shell

```

[Linux下用火焰图进行性能分析](https://blog.csdn.net/gatieme/article/details/78885908)

### systemtap
