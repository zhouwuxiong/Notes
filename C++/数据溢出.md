## 数据溢出处理
- C/C++ 数据溢出产生的进位会被舍弃
- c/C++ 数据值域类似一个环，当超出最大值时，从最小值开始。

###  有符号数溢出
127 溢出 -> -127
-127 溢出 -> 127

### 无符号数溢出
127 溢出 -> 0
0 溢出 -> 127

### 浮点数溢出
1. 阶码上溢出
  正指数（即阶码值）超过了最大允许值

  比如阶码用8bit移码表示，正指数却有128,即无法表示（8bit移码中真值表示范围为-126～127,-127的阶码全0表示非规格化数;而-128的阶码全1,表示无穷大）即上溢出
  
  阶码上溢出会产生软件故障，需要引入溢出故障处理程序来处理
  
2. 阶码下溢出
  一个负指数比最小所允许的数值还要小时，发生下溢出，
  
  例如上面例子中用阶码表示-130，小于真值表示范围的最小值，发生下溢出。
  
  一般机器把下溢出时的值置为0.

3. 尾数溢出
  当尾数中最高有效位发生进位时，发生尾数溢出。

  此时，需要进行 “右规格化”操作：尾数右移一位，阶码加1,直到尾数不再溢出。不过右移过程中可能会舍入，引起误差。

4. 非规格化尾数
  非规格化尾数，当数值部分高位不是有效值时，例如：
- 尾数用原码表示则尾数最高数值位必须为1
- 尾数用补码表示则符号位必须与最高数值位相反

  此时需要进行“左规格化”操作：尾数左移一位，阶码减1,直到尾数为规格化为止。

总结：
浮点数溢出最终都可以归一成阶码溢出，比如情况3和情况4,通过规格化操作进行算数移位来增减阶码，如果阶码变动之后，大于阶码表示范围的最大值，则是上溢出;小于阶码表示范围的最小值，则是下溢出。

[浮点数溢出](https://blog.csdn.net/m0_45210226/article/details/119648316)

## INF 和 NaN
INF 超出浮点数的表示范围（溢出，即阶码部分超过其能表示的最大值）。
### 产生NaN的原因
1、对负数开方，如：−1.0‾‾‾‾‾√;
2、对负数求对数，如：log(−1.0)；
3、0.0 / 0.0；
4、0.0 * inf；
5、inf / inf；
6、nf-inf这些操作都会得到nan。
(**0 / 0会产生操作异常；0.0 / 0.0不会产生操作异常，而是会得到nan**)；


nan是无序的（unordered），无法对其进行逻辑运算。它不大于、小于或等于任何数（包括它自己），**将<，>，<=，和>=作用于nan产生一个exception**。得到nan时就查看是否有非法操作，如果表达式中含有nan，那么表达式的结果为nan。

+inf大于任何数（除了它自己和nan），-inf小于任何数（除了它自己和nan），得到inf时就查看是否有溢出或者除以0。inf在C语言表达式中就表示数学里无限的概念，如1.0/inf等于0.0，并可以与其他浮点数进行比较的（**inf 可以参与<=、>+、==、!=等运算**）

[C、C++中出现nan、inf原因](https://blog.csdn.net/qq_16334327/article/details/86526854)

### signaling NaN与Quiet NaN
signaling NaN： 会立即触发浮点数异常的非数
Quiet NaN： 不会触发浮点数异常，指导程序检查和读取该数

ARMv8官方编程指南中，它们对SNaN与QNaN的编码方式是一样的，即无视符号位；指数部分为全1；尾数部分中，如果最高位为0，且尾数不为全0，则该浮点数为SNaN，而如果尾数最高位为1，则该浮点数为QNaN。

[What is difference between quiet NaN and signaling NaN?](https://www.e-learn.cn/topic/146980)

[c++数值极限numeric_limits](https://blog.csdn.net/yhc166188/article/details/90287807)

### set中无法插入NaN
因为set是一个排序容器，在每次插入是需要查重和排序，std在比较元素是否相同时通过`!comp(a, b) && !comp(b, a)`逻辑进行计算，当计算`NaN`时得到`true && true`，因此不会插入。